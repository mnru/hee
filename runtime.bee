:: bool
 | true
 | false
 ;

:: list
 | null
 | cons head tail
 ;

:: option
 | some a
 | none
 ;

:: either
 | left a
 | right b
 ;

: if
  unbool ;

: or
  [pop true] [id]  unbool ;

: and
  [id] [pop false] unbool ;

: xor
  [not] [id] unbool ;

: not
  false true unbool ;

: filter
  reverse-filter reverse ;

: even?
  2 % 0 == ;

: odd?
  2 % 1 == ;

: foldr
  dig [pop] [swap [bury] dip bury dup [foldr] dip apply] unlist ;

: bury
  swap [swap] dip ;

: bottles
  dup dup to_s ' bottles' concat print 0 == [pop] [1 - bottles] if ;

: twice
  dup compose apply ;

: foldl'
  [dup quote compose] dip compose [quote dup] dip compose unlist ;

: foldl
  [foldl'] y ;

: reverse-map
  null [swap] dig compose [cons] compose foldl ;

: reverse
  null [swap cons] foldl ;

: map
  reverse-map reverse ;

: length
  0 [[pop] dip 1 +] foldl ;

: sum
  0 [+] foldl ;

: product
  1 [*] foldl ;

: null?
  [true] [pop pop false] unlist ;

: cons?
  [false] [pop pop true] unlist ;

: y'
  dup quote [y'] compose quote swap compose apply ;

: y
  quote [dup apply] swap compose [apply] compose quote [quote] swap compose [compose] compose dup apply apply ;

: !'
  swap dup 1 == [pop pop] [-1 + dup dig [[*] dip] dip apply] if ;

: !
  dup [!'] y ;

: +xs
  5 cons 4 cons 3 cons 2 cons 1 cons ;

: times'
  swap dup 0 == [pop pop pop] [1 - [[dup [apply] dip] dip] dip swap apply] if ;

: times
  [times'] y ;

: concat
  [swap cons] foldr ;

: reverse-filter
  [swap dup] swap compose [[cons] [pop] if] compose null swap foldl ;

: accgen'
  quote [dup] swap compose [+] compose quote [quote] swap compose quote [dip compose compose] compose ;

: accgen
  accgen' y ;


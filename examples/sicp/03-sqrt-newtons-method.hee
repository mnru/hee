sqrt_
  : frac → frac
  "
  " Write-only monolithic definition that works without having to
  " define any other terms (uses anonymous recursion)
  "
  = 1.0                         -- initial guess
    [bury                       -- recursive function
     dup2                       -- [rec] x guess → [rec] x guess x guess
     dup * -                    -- distance from correct answer
     dup 0.0 < [-1.0 *] [id] if -- absolute value
     0.001 <
       [[pop pop] dip]          -- [rec] x guess → guess DONE
       [[dup] both              -- [rec] x guess → [rec] x x guess guess
        [/] dip                 -- [rec] x (x/guess) guess
        + 2.0 /                 -- [rec] x avg(x/guess, guess)
        dig u]                  -- x guess' REC
     if] u

sqrt
  : frac → frac
  "
  " Newton's method of successive approximations:
  "   From a guess y for the value of the square root of a number x;
  "   we can improve our guess by averaging y with x/y. For example,
  "   supposing our first guess is 1, we compute the square root of
  "   2 as follows:
  "
  "     Guess   Quotient           Average
  "     -----------------------------------------------------
  "     1       2/1      = 2       (2+1)/2           = 1.5
  "     1.5     2/1.5    = 1.3333  (1.3333+1.5)/2    = 1.4167
  "     1.4167  2/1.4167 = 1.4118  (1.4167+1.4118)/2 = 1.4142
  "     1.4142  ...
  "
  "   Continuing this process, we obtain a better approximation of
  "   the square root.
  "
  = 1.0 swap [sqrt'] u

sqrt'
  : frac frac RECURSIVE → frac
  "
  " x guess [sqrt'] sqrt'
  "
  = bury
    dup2 good-enough?
      [[pop pop] dip]       -- [RECURSIVE] x guess → guess
      [over improve dig u]  -- [RECURSIVE] x guess → x guess' RECURSIVE
    if

good-enough?
  : frac frac → bool
  "
  " The answer should be improved until its square differs from the
  " radicand by less than a predetermined tolerance (here, 0.001).
  "
  " Example:
  "   >> 10.0 3.0 good-enough?
  "   => false
  "
  "   >> 10.0 3.1624 good-enough?
  "   => true
  "
  = square - abs 0.001 <

square
  : frac frac → frac
  = dup *

abs
  : frac → frac
  = dup 0.0 < [negate] [id] if

negate
  : frac → frac
  = -1.0 *

improve
  : frac frac → frac
  "
  " A guess is improved by averaging it with the quotient of the
  " radicand and the old guess
  "
  " Example:
  "   >> 10.0 1.0 improve
  "   => 5.5
  "
  = dup [/] dip average

average
  : frac frac → frac
  "
  " Example:
  "   >> 10.0 20.0 average
  "   => 15.0
  "
  = + 2.0 /
